<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø®Ù…Ù† Ø§Ù„Ø±Ø³Ù…Ø© - Ø§Ø±Ø³Ù…</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* CSS Ù„ØªÙ‚Ù„ÙŠØ¯ ØªØµÙ…ÙŠÙ… DoodleGator (Ø£Ù„ÙˆØ§Ù† Telegram Mini App) */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--tg-theme-bg-color, #f1f1f1);
            color: var(--tg-theme-text-color, #000000);
            min-height: 100vh;
        }

        .header {
            width: 100%;
            text-align: center;
            padding: 15px 0;
        }

        .word-display {
            font-size: 24px;
            font-weight: bold;
            color: var(--tg-theme-link-color, #168acd);
        }

        .canvas-container {
            width: 90%;
            max-width: 500px;
            aspect-ratio: 1 / 1; /* Ù„Ø¬Ø¹Ù„Ù‡Ø§ Ù…Ø±Ø¨Ø¹Ø© */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            overflow: hidden;
            background-color: white;
            margin-bottom: 20px;
        }

        #drawingCanvas {
            width: 100%;
            height: 100%;
            touch-action: none; /* Ù„Ù…Ù†Ø¹ Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±Ø³Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ */
        }

        .controls-panel {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            padding: 10px;
            background-color: var(--tg-theme-secondary-bg-color, #ffffff);
            width: 100%;
            box-sizing: border-box;
            border-top: 1px solid var(--tg-theme-section-separator-color, #e7e7e7);
        }

        .control-button {
            background-color: var(--tg-theme-button-color, #40a7e3);
            color: var(--tg-theme-button-text-color, #ffffff);
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .control-button.active {
            background-color: var(--tg-theme-accent-text-color, #168acd);
        }
        
        /* Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø®Ø· ÙˆØ§Ù„Ù„ÙˆÙ† */
        .settings-row {
            width: 90%;
            max-width: 500px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 0 15px 0;
        }

        #colorPicker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            overflow: hidden;
            background: transparent;
        }

        #colorPicker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        #colorPicker::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }

        #penSizeSlider {
            width: 70%;
            -webkit-appearance: none;
            height: 8px;
            background: var(--tg-theme-hint-color, #999999);
            border-radius: 4px;
        }

        #penSizeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--tg-theme-button-color, #40a7e3);
            cursor: pointer;
        }
        #confirmButton {
            width: 90%;
            max-width: 500px;
            margin-top: 15px;
            height: 50px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <span class="word-display" id="wordToDraw">ØªØ­Ù…ÙŠÙ„...</span>
    </div>

    <div class="settings-row">
        <button id="undoButton" class="control-button" title="ØªØ±Ø§Ø¬Ø¹">â†©ï¸</button>
        <button id="redoButton" class="control-button" title="Ø¥Ø¹Ø§Ø¯Ø©">â†ªï¸</button>
        <input type="range" id="penSizeSlider" min="2" max="30" value="7">
        <input type="color" id="colorPicker" value="#000000" title="Ù„ÙˆÙ†">
    </div>

    <div class="canvas-container">
        <canvas id="drawingCanvas"></canvas>
    </div>

    <div class="controls-panel">
        <button id="penButton" class="control-button active" title="Ù‚Ù„Ù…">âœï¸</button>
        <button id="eraserButton" class="control-button" title="Ù…Ù…Ø­Ø§Ø©">ğŸ§¼</button>
        <button id="clearButton" class="control-button" title="Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø©">âŒ</button>
        <button id="sendDrawingButton" class="control-button" title="Ø£ÙƒÙŠØ¯ØŒ Ø£Ø±Ø³Ù„!">âœ…</button>
    </div>
    
    <button id="confirmButton" class="control-button" onclick="sendDrawing()">Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ù…Ø© Ù„Ù„Ù‚Ø±ÙˆØ¨</button>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const wordToDrawElement = document.getElementById('wordToDraw');
        const penButton = document.getElementById('penButton');
        const eraserButton = document.getElementById('eraserButton');
        const clearButton = document.getElementById('clearButton');
        const colorPicker = document.getElementById('colorPicker');
        const penSizeSlider = document.getElementById('penSizeSlider');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let history = []; // Ù„Ø³Ø¬Ù„ Ø§Ù„ØªØ±Ø§Ø¬Ø¹/Ø§Ù„ØªÙ‚Ø¯ÙŠÙ…
        let historyIndex = -1;
        let isErasing = false;
        let currentSize = parseInt(penSizeSlider.value);
        let currentColor = colorPicker.value;

        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ø³ØªÙ„Ù…Ø©
        let chatId = null;
        let userId = null;
        let secretWord = "Ø§Ù„ÙƒÙ„Ù…Ø©"; // Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©

        // ------------------------------
        // 1. ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙˆØª ÙˆÙ‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        // ------------------------------

        document.addEventListener('DOMContentLoaded', () => {
            // ØªÙ‡ÙŠØ¦Ø© ÙˆØ§Ø¬Ù‡Ø© Web App
            if (window.Telegram && window.Telegram.WebApp) {
                Telegram.WebApp.ready();
                // Ø¥Ø®ÙØ§Ø¡ Ø²Ø± Close Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„ÙƒÙŠ Ù†Ø³ØªØ®Ø¯Ù… Ø²Ø± Ø§Ù„ØªØ£ÙƒÙŠØ¯ ÙÙŠ Ø§Ù„Ø£Ø³ÙÙ„
                Telegram.WebApp.BackButton.hide();
                Telegram.WebApp.MainButton.hide();

                // Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† URL (Ø§Ù„ØªÙŠ Ù…Ø±Ø±Ù†Ø§Ù‡Ø§ ÙƒØ¨Ø§Ø±Ø§Ù…ØªØ±Ø§Øª)
                const urlParams = new URLSearchParams(window.location.search);
                
                secretWord = urlParams.get('word') || "Ø®Ø·Ø£: Ø§Ù„ÙƒÙ„Ù…Ø© Ù…ÙÙ‚ÙˆØ¯Ø©";
                chatId = urlParams.get('chat_id');
                userId = urlParams.get('user_id');

                wordToDrawElement.textContent = secretWord;
            }

            // Ù„Ø¬Ø¹Ù„ Canvas ÙŠÙ…Ù„Ø£ Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø­Ø§ÙˆÙŠØ© Ø¯Ø§Ø¦Ù…Ù‹Ø§
            const container = document.querySelector('.canvas-container');
            const size = container.offsetWidth;
            canvas.width = size;
            canvas.height = size;
            
            // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = currentSize;
            ctx.strokeStyle = currentColor;
            
            // Ø¥Ø¶Ø§ÙØ© Ø®Ù„ÙÙŠØ© Ø¨ÙŠØ¶Ø§Ø¡ Ù„ÙƒÙŠ ÙŠÙ…ÙƒÙ† ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ù„Ù€ PNG Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveState(); // Ø­ÙØ¸ Ø­Ø§Ù„Ø© Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ©

            // Ø±Ø¨Ø· Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
            attachEventListeners();
        });


        // ------------------------------
        // 2. Ø¯ÙˆØ§Ù„ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        // ------------------------------

        function draw(e) {
            if (!isDrawing) return;
            
            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù„Ù…Ø³/Ø§Ù„Ù…Ø§ÙˆØ³ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„Ù€ Canvas
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            
            ctx.lineWidth = currentSize;
            ctx.strokeStyle = isErasing ? 'white' : currentColor;
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();

            [lastX, lastY] = [x, y];
        }

        function startDrawing(e) {
            isDrawing = true;
            
            // ØªØ­Ø¯ÙŠØ¯ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            
            [lastX, lastY] = [x, y];
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveState();
            }
        }

        function attachEventListeners() {
            // Mouse Events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            // Touch Events (Ù„Ù„Ù‡ÙˆØ§ØªÙ)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Ù…Ù†Ø¹ Ø³Ù„ÙˆÙƒ Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ (Ø§Ù„ØªÙ…Ø±ÙŠØ±)
                startDrawing(e);
            });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                draw(e);
            });
            canvas.addEventListener('touchend', stopDrawing);

            // ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯ÙˆØ§Øª
            colorPicker.addEventListener('change', (e) => {
                currentColor = e.target.value;
                if (!isErasing) ctx.strokeStyle = currentColor;
                penButton.classList.add('active');
                eraserButton.classList.remove('active');
                isErasing = false;
            });
            
            penSizeSlider.addEventListener('input', (e) => {
                currentSize = parseInt(e.target.value);
            });

            penButton.addEventListener('click', () => {
                isErasing = false;
                penButton.classList.add('active');
                eraserButton.classList.remove('active');
            });

            eraserButton.addEventListener('click', () => {
                isErasing = true;
                penButton.classList.remove('active');
                eraserButton.classList.add('active');
            });

            clearButton.addEventListener('click', clearCanvas);

            undoButton.addEventListener('click', undo);
            redoButton.addEventListener('click', redo);
        }

        // ------------------------------
        // 3. Ø§Ù„ØªØ±Ø§Ø¬Ø¹ ÙˆØ§Ù„Ø­ÙØ¸
        // ------------------------------

        function saveState() {
            // Ø¥Ø°Ø§ ÙƒÙ†Ø§ Ù‚Ø¯ ØªØ±Ø§Ø¬Ø¹Ù†Ø§ØŒ Ø³Ù†Ø­Ø°Ù Ø£ÙŠ Ø®Ø·ÙˆØ§Øª Ù„Ø§Ø­Ù‚Ø© (Redo history)
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            // Ù†Ø­ÙØ¸ Ø§Ù„Ù„ÙˆØ­Ø© ÙƒÙ€ Base64
            const dataURL = canvas.toDataURL();
            history.push(dataURL);
            historyIndex++;
        }

        function restoreState(index) {
            if (index < 0 || index >= history.length) return;
            
            const img = new Image();
            img.onload = () => {
                // Ù†Ø¹ÙŠØ¯ Ø§Ù„Ø±Ø³Ù… Ø¹Ù„Ù‰ Ù„ÙˆØ­Ø© Ø¨ÙŠØ¶Ø§Ø¡ Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ÙˆØ¶ÙˆØ­
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
            img.src = history[index];
            historyIndex = index;
        }

        function undo() {
            if (historyIndex > 0) {
                restoreState(historyIndex - 1);
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                restoreState(historyIndex + 1);
            }
        }

        function clearCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveState();
        }


        // ------------------------------
        // 4. Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª
        // ------------------------------
        
        function sendDrawing() {
            if (!Telegram.WebApp || !Telegram.WebApp.sendData) {
                alert("ÙˆØ§Ø¬Ù‡Ø© ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø£Ùˆ ØºÙŠØ± Ù…Ù‡ÙŠØ¦Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.");
                return;
            }

            if (!chatId || !userId || secretWord === "Ø®Ø·Ø£: Ø§Ù„ÙƒÙ„Ù…Ø© Ù…ÙÙ‚ÙˆØ¯Ø©") {
                 alert("Ø®Ø·Ø£ ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ù„Ø³Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù† Ø§Ù„Ø¨ÙˆØª.");
                 return;
            }

            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø±Ø³Ù…Ø© Ø¥Ù„Ù‰ Base64
            const drawingDataURL = canvas.toDataURL('image/png');
            
            // ØªÙ‡ÙŠØ¦Ø© Ø¨ÙŠØ§Ù†Ø§Øª JSON
            const data = {
                chat_id: chatId,
                user_id: userId,
                drawing_data: drawingDataURL 
            };
            
            try {
                // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª
                Telegram.WebApp.sendData(JSON.stringify(data));
                
                // Ø¥ØºÙ„Ø§Ù‚ Ù†Ø§ÙØ°Ø© Ø§Ù„ÙˆÙŠØ¨ (Ø£Ùˆ Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯)
                alert("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­! ÙŠÙ…ÙƒÙ†Ùƒ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù†Ø§ÙØ°Ø©.");
                Telegram.WebApp.close();
            } catch (e) {
                alert("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: " + e.message);
            }
        }
    </script>
</body>
</html>
