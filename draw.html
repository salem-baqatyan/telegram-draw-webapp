<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Telegram WebApp - Drawer</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#06b6d4;--muted:#9ca3af}
    html,body{height:100%;margin:0;font-family:Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#071022 0%, #071827 100%);color:#e6eef6}
    .app{max-width:900px;margin:18px auto;padding:12px;border-radius:12px;background:var(--panel);box-shadow:0 6px 30px rgba(2,6,23,.6)}
    header{display:flex;gap:12px;align-items:center}
    header h1{font-size:18px;margin:0}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button{background:none;border:1px solid rgba(255,255,255,.06);padding:8px 12px;border-radius:10px;color:inherit;cursor:pointer}
    button.primary{background:var(--accent);color:#012; border:0}
    #canvasWrap{margin-top:12px;border-radius:8px;overflow:hidden;background:#fff}
    canvas{display:block;width:100%;height:480px;background:#fff;touch-action:none}
    .tools{display:flex;gap:8px;align-items:center}
    select,input[type=range]{appearance:none;padding:6px;border-radius:8px;background:rgba(255,255,255,.03);color:inherit;border:1px solid rgba(255,255,255,.04)}
    footer{display:flex;justify-content:space-between;align-items:center;margin-top:12px}
    .muted{color:var(--muted);font-size:13px}
    @media (max-width:600px){canvas{height:360px}}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Ù…Ø­Ø±Ø± Ø§Ù„Ø±Ø³Ù… - Telegram WebApp</h1>
      <div style="margin-left:auto" class="muted">Ø§Ø¶ØºØ· Ø¥Ø±Ø³Ø§Ù„ Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ù„Ø¨ÙˆØª Ø§Ù„ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…</div>
    </header>

    <div class="controls">
      <div class="tools">
        <label for="color">Ø§Ù„Ù„ÙˆÙ†</label>
        <input id="color" type="color" value="#000000" />
        <label for="size">Ø§Ù„Ø­Ø¬Ù…</label>
        <input id="size" type="range" min="1" max="60" value="4" />
        <button id="eraser">Ù…Ù…Ø­Ø§Ø©</button>
        <button id="undo">ØªØ±Ø§Ø¬Ø¹</button>
        <button id="clear">Ù…Ø³Ø­</button>
      </div>
      <div style="margin-left:auto;display:flex;gap:8px">
        <button id="download">ØªØ­Ù…ÙŠÙ„</button>
        <button id="send" class="primary">Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ø¨ÙˆØª</button>
      </div>
    </div>

    <div id="canvasWrap">
      <canvas id="board" width="1200" height="720"></canvas>
    </div>

    <footer>
      <div class="muted">Ø³Ù‡Ù„ â€” Ù„Ù…Ø³/ÙØ£Ø±Ø© Ù„Ù„Ø±Ø³Ù… â€” ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ù…ØªØµÙØ­Ø§Øª Ø­Ø¯ÙŠØ«Ø©</div>
      <div class="muted">Ø­Ø¬Ù… Ø§Ù„Ù„ÙˆØ­Ø©: <span id="sizeLabel">4</span></div>
    </footer>
  </div>

  <script>
    // ======= Telegram WebApp init (if opened from Telegram) =======
    const isTelegram = typeof window.Telegram !== 'undefined' && !!window.Telegram.WebApp;
    if (isTelegram) {
      window.Telegram.WebApp.init();
      // Expand to full height inside Telegram
      try { window.Telegram.WebApp.expand(); } catch(e){}
    }

    // ======= Canvas drawing logic =======
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d', { alpha: true });
    const colorInput = document.getElementById('color');
    const sizeInput = document.getElementById('size');
    const sizeLabel = document.getElementById('sizeLabel');
    const eraserBtn = document.getElementById('eraser');
    const clearBtn = document.getElementById('clear');
    const undoBtn = document.getElementById('undo');
    const downloadBtn = document.getElementById('download');
    const sendBtn = document.getElementById('send');

    // make canvas resolution friendly
    function fitToContainer() {
      const ratio = window.devicePixelRatio || 1;
      const width = canvas.clientWidth;
      const height = Math.round(width * (3/5)); // keep aspect ratio
      canvas.width = Math.round(width * ratio);
      canvas.height = Math.round(height * ratio);
      canvas.style.height = height + 'px';
      ctx.scale(ratio, ratio);
      redraw();
    }
    window.addEventListener('resize', fitToContainer);
    fitToContainer();

    // drawing state
    let drawing = false;
    let paths = []; // history of paths for undo
    let currentPath = null;
    let tool = 'pen';

    function start(x,y){
      drawing=true;
      currentPath = {tool, color: ctx.strokeStyle, size: ctx.lineWidth, points:[{x,y}]};
      paths.push(currentPath);
    }
    function move(x,y){
      if(!drawing) return;
      const p = currentPath.points;
      p.push({x,y});
      drawPathSegment(currentPath);
    }
    function end(){ drawing=false; currentPath=null }

    function drawPathSegment(path){
      const pts = path.points;
      if(pts.length < 2) return;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeStyle = path.tool === 'eraser' ? '#ffffff' : path.color;
      ctx.globalCompositeOperation = path.tool === 'eraser' ? 'destination-out' : 'source-over';
      ctx.lineWidth = path.size;

      ctx.beginPath();
      ctx.moveTo(pts[pts.length-2].x, pts[pts.length-2].y);
      ctx.lineTo(pts[pts.length-1].x, pts[pts.length-1].y);
      ctx.stroke();
    }

    // redraw from history (used after resize or undo)
    function redraw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // When canvas scaled by ratio, width/height are in device px; draw using client coords
      for(const p of paths){
        if(!p.points || p.points.length < 2) continue;
        ctx.lineJoin='round';ctx.lineCap='round';
        ctx.strokeStyle = p.tool === 'eraser' ? '#ffffff' : p.color;
        ctx.globalCompositeOperation = p.tool === 'eraser' ? 'destination-out' : 'source-over';
        ctx.lineWidth = p.size;
        ctx.beginPath();
        ctx.moveTo(p.points[0].x, p.points[0].y);
        for(let i=1;i<p.points.length;i++) ctx.lineTo(p.points[i].x, p.points[i].y);
        ctx.stroke();
      }
      // restore composite mode
      ctx.globalCompositeOperation = 'source-over';
    }

    // pointer events (works for touch + mouse)
    function getPointerPos(e){
      const rect = canvas.getBoundingClientRect();
      const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
      const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
      return {x: clientX - rect.left, y: clientY - rect.top};
    }
    canvas.addEventListener('pointerdown', e=>{ canvas.setPointerCapture(e.pointerId); const p=getPointerPos(e); start(p.x,p.y);});
    canvas.addEventListener('pointermove', e=>{ const p=getPointerPos(e); move(p.x,p.y);});
    canvas.addEventListener('pointerup', e=>{ canvas.releasePointerCapture(e.pointerId); end();});
    canvas.addEventListener('pointerleave', end);

    // tool controls
    colorInput.addEventListener('input', ()=>{ ctx.strokeStyle = colorInput.value; tool='pen'; });
    sizeInput.addEventListener('input', ()=>{ ctx.lineWidth = parseInt(sizeInput.value,10); sizeLabel.textContent = sizeInput.value; });
    eraserBtn.addEventListener('click', ()=>{ tool='eraser'; });
    clearBtn.addEventListener('click', ()=>{ paths=[]; redraw(); });
    undoBtn.addEventListener('click', ()=>{ paths.pop(); redraw(); });
    downloadBtn.addEventListener('click', ()=>{
      const data = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = data; a.download = 'drawing.png'; a.click();
    });

    // initial pen config
    ctx.strokeStyle = colorInput.value;
    ctx.lineWidth = parseInt(sizeInput.value,10);

    // ======= Sending to Telegram Bot =======
    // When inside Telegram WebApp, use Telegram.WebApp.sendData to send the base64 image string to the bot.
    // The bot will receive an update containing message.web_app_data with the data you send.
    sendBtn.addEventListener('click', async ()=>{
      // ensure there's something drawn
      if(paths.length === 0) {
        alert('Ù„ÙˆØ­Ø© Ø§Ù„Ø±Ø³Ù… ÙØ§Ø±ØºØ© â€” Ø§Ø³Ø­Ø¨ Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù….');
        return;
      }

      // get a trimmed PNG (optional: here we send full canvas)
      const dataUrl = canvas.toDataURL('image/png');
      const payload = {
        type: 'drawing',
        timestamp: Date.now(),
        data: dataUrl
      };

      if(isTelegram){
        try{
          window.Telegram.WebApp.sendData(JSON.stringify(payload));
          // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¸Ù‡Ø§Ø± Ø±Ø³Ø§Ù„Ø© Ù†Ø¬Ø§Ø­ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
          if(window.Telegram.WebApp.BackButton) window.Telegram.WebApp.showPopup && window.Telegram.WebApp.showPopup({title:'ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„', message:'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ù… Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª.'});
        }catch(e){
          alert('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª: '+e.message);
        }
      } else {
        // Ø®Ø§Ø±Ø¬ Ø§Ù„ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…: Ù†Ø¬Ø±ÙŠ POST Ø¥Ù„Ù‰ endpoint (Ø®ÙŠØ§Ø±ÙŠØŒ Ù…ÙÙŠØ¯ Ù„Ù„ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø­Ù„ÙŠØ©)
        try{
          const res = await fetch('/upload', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
          if(res.ok) alert('ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ± (Ù„ÙŠØ³ Ø¹Ø¨Ø± ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…).'); else alert('ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±.');
        }catch(err){ alert('Ø®Ø·Ø£ Ø§ØªØµØ§Ù„: '+err.message); }
      }
    });

    // Allow drawing with mouse when pointer events missing
    // (pointer events are used above; this is for older browsers fallback)
  </script>

  <!--
    Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ù†Ø´Ø±:
    1) ÙŠØ¬Ø¨ Ø§Ø³ØªØ¶Ø§ÙØ© Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø© Ø¹Ù„Ù‰ HTTPS (ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… ÙŠØªØ·Ù„Ø¨ HTTPS).
    2) Ø¹Ù†Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ø²ÙØ± WebApp Ù…Ù† Ø§Ù„Ø¨ÙˆØªØŒ Ø¶Ø¹ Ø±Ø§Ø¨Ø· Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø© ÙƒØ±Ø§Ø¨Ø· WebApp.
       Ù…Ø«Ø§Ù„ ÙÙŠ python-telegram-bot: InlineKeyboardButton('Ø±Ø³Ù…', web_app=WebAppInfo(url='https://your-domain.com/draw.html'))
    3) Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ¶ØºØ· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… "Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ø¨ÙˆØª" Ø¯Ø§Ø®Ù„ WebAppØŒ Ø³ÙŠØ³ØªÙ„Ù… Ø§Ù„Ø¨ÙˆØª Ø±Ø³Ø§Ù„Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ update.message.web_app_data.data.
       Ù‡Ø°Ø§ Ø§Ù„Ø­Ù‚Ù„ Ø³ÙŠÙƒÙˆÙ† JSON Ù…Ù†Ø³Ù‚ ÙƒÙ…Ø§ ÙÙŠ payload Ø£Ø¹Ù„Ø§Ù‡ â€” Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ dataUrl ÙˆØ­ÙˆÙ„Ù‡Ø§ Ø¥Ù„Ù‰ Ù…Ù„Ù ØµÙˆØ±Ø©.

    Ø£Ø³ÙÙ„ ÙŠÙˆØ¬Ø¯ Ù…Ø«Ø§Ù„ Ù…Ø®ØªØµØ± Ù„ÙƒÙŠÙÙŠØ© Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª (python-telegram-bot v20+):

    async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
        msg = update.message
        if msg and msg.web_app_data:
            try:
                payload = json.loads(msg.web_app_data.data)
                if payload.get('type') == 'drawing':
                    data_url = payload['data']  # 'data:image/png;base64,....'
                    header, b64 = data_url.split(',', 1)
                    data = base64.b64decode(b64)
                    bio = io.BytesIO(data)
                    bio.name = 'drawing.png'
                    bio.seek(0)
                    await context.bot.send_photo(chat_id=msg.chat_id, photo=bio, caption='ğŸ¨ Ø±Ø³Ù… Ù…Ù† WebApp')
            except Exception as e:
                # Ø³Ø¬Ù„ Ø§Ù„Ø®Ø·Ø£
                pass
  -->
</body>
</html>
