<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Ø£Ø¯Ø§Ø© Ø§Ù„Ø±Ø³Ù… ÙÙŠ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…</title>
<style>
  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #0d1117;
    color: #fff;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    padding: 10px;
    background: #161b22;
    text-align: center;
  }
  #toolbar {
    display: flex;
    gap: 8px;
    justify-content: center;
    align-items: center;
    background: #161b22;
    padding: 8px;
    flex-wrap: wrap;
  }
  button, input[type=color], input[type=range] {
    border: none;
    border-radius: 8px;
    padding: 8px;
    font-size: 14px;
    cursor: pointer;
  }
  button {
    background: #238636;
    color: white;
  }
  #clear, #undo {
    background: #d73a49;
  }
  canvas {
    flex: 1;
    touch-action: none;
    background: #fff;
    display: block;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
  <header>ğŸ¨ Ø£Ø¯Ø§Ø© Ø§Ù„Ø±Ø³Ù… ÙÙŠ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…</header>
  <div id="toolbar">
    <label>Ù„ÙˆÙ†:</label> <input type="color" id="color" value="#000000">
    <label>Ø­Ø¬Ù…:</label> <input type="range" id="size" min="1" max="50" value="4">
    <button id="undo">â†©ï¸ ØªØ±Ø§Ø¬Ø¹</button>
    <button id="clear">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
    <button id="send">ğŸ“¤ Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ø¨ÙˆØª</button>
  </div>
  <canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let drawing = false;
let paths = [];
let currentPath = [];
let color = document.getElementById('color').value;
let size = document.getElementById('size').value;

// ğŸ”¹ ØªÙ‡ÙŠØ¦Ø© Telegram WebApp
const isTelegram = window.Telegram && window.Telegram.WebApp;
if (isTelegram) {
  Telegram.WebApp.ready();
  Telegram.WebApp.expand();
}

// Ø¶Ø¨Ø· Ø­Ø¬Ù… Ø§Ù„Ù„ÙˆØ­Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight - 40;
  redraw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ· Ù…Ù† Ø§Ù„ØªØ§Ø±ÙŠØ®
function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let path of paths) {
    ctx.strokeStyle = path.color;
    ctx.lineWidth = path.size;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    for (let i = 1; i < path.points.length; i++) {
      const p1 = path.points[i - 1];
      const p2 = path.points[i];
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
    }
    ctx.stroke();
  }
}

function startDraw(x, y) {
  drawing = true;
  currentPath = { color, size, points: [{ x, y }] };
  paths.push(currentPath);
}
function draw(x, y) {
  if (!drawing) return;
  const p = currentPath.points;
  p.push({ x, y });
  ctx.strokeStyle = currentPath.color;
  ctx.lineWidth = currentPath.size;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  const prev = p[p.length - 2];
  ctx.moveTo(prev.x, prev.y);
  ctx.lineTo(x, y);
  ctx.stroke();
}
function endDraw() {
  drawing = false;
  currentPath = [];
}

// ğŸ¨ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« (ÙŠØ¹Ù…Ù„ Ø¨Ø§Ù„Ù„Ù…Ø³ ÙˆØ§Ù„ÙØ£Ø±Ø©)
function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches ? e.touches[0] : e;
  return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
}
canvas.addEventListener('mousedown', e => startDraw(...Object.values(getPos(e))));
canvas.addEventListener('mousemove', e => draw(...Object.values(getPos(e))));
canvas.addEventListener('mouseup', endDraw);
canvas.addEventListener('mouseleave', endDraw);
canvas.addEventListener('touchstart', e => { e.preventDefault(); startDraw(...Object.values(getPos(e))); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); draw(...Object.values(getPos(e))); });
canvas.addEventListener('touchend', endDraw);

// Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ…
document.getElementById('color').addEventListener('input', e => color = e.target.value);
document.getElementById('size').addEventListener('input', e => size = e.target.value);
document.getElementById('clear').addEventListener('click', () => { paths = []; redraw(); });
document.getElementById('undo').addEventListener('click', () => { paths.pop(); redraw(); });

// Ø²Ø± Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ø¨ÙˆØª
document.getElementById('send').addEventListener('click', () => {
  if (paths.length === 0) return alert('ğŸ¨ Ø§Ù„Ù„ÙˆØ­Ø© ÙØ§Ø±ØºØ©!');
  const dataUrl = canvas.toDataURL('image/png');
  const payload = JSON.stringify({ type: 'drawing', data: dataUrl, timestamp: Date.now() });

  if (isTelegram) {
    Telegram.WebApp.sendData(payload);
    Telegram.WebApp.close(); // ÙŠØºÙ„Ù‚ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
  } else {
    alert('ğŸš« Ø§ÙØªØ­ Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø© Ù…Ù† Ø¯Ø§Ø®Ù„ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… Ù„ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„.');
  }
});
</script>
</body>
</html>
